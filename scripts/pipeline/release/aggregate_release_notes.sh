#!/usr/bin/env bash
# Aggregate per-app ReleaseNotes.txt into Markdown release notes.
# Usage:
#   scripts/aggregate_release_notes.sh [--write] [--out-dir docs/releases] [paths...]
# By default this is a dry-run and prints to stdout. Use --write to write files under --out-dir.

set -euo pipefail

OUT_DIR="docs/releases"
WRITE=0
ARGS=()

while [[ $# -gt 0 ]]; do
  case "$1" in
    --write) WRITE=1; shift ;;
    --out-dir) OUT_DIR="$2"; shift 2 ;;
    --help|-h) echo "Usage: $0 [--write] [--out-dir DIR] [paths...]"; exit 0 ;;
    --*) echo "Unknown option: $1"; exit 2 ;;
    *) ARGS+=("$1"); shift ;;
  esac
done

if [ ${#ARGS[@]} -eq 0 ]; then
  RN_GLOBS=(bin/*/*/ReleaseNotes.txt)
else
  RN_GLOBS=("${ARGS[@]}")
fi

declare -A entries_by_version
declare -A version_date
declare -a version_order

trim() { echo "$1" | sed -e 's/^\s*//' -e 's/\s*$//'; }

process_file() {
  local file="$1"
  [ -f "$file" ] || return

  # header values
  local v d
  v=$(grep -m1 '^# @version' "$file" | awk -F: '{print $2}' 2>/dev/null || true)
  d=$(grep -m1 '^# @date' "$file" | awk -F: '{print $2}' 2>/dev/null || true)
  v=$(trim "$v")
  d=$(trim "$d")
  key="$v"

  if [ -z "${version_date[$key]:-}" ]; then
    version_date[$key]="$d"
    version_order+=("$key")
  fi

  while IFS= read -r line; do
    # match lines that start with v<...>,
    [[ "$line" =~ ^v ]] || continue
    # remove leading 'v...' up to first comma
    # line format: v1.0.6.70, cccd998, Updating release script.
    rest="${line#*,}"
    hash="$(echo "${rest%%,*}" | xargs)"
    msg="$(echo "${rest#*,}" | xargs)"

    # normalize hash if possible
    if git rev-parse --verify --quiet "$hash" >/dev/null 2>&1; then
      short=$(git rev-parse --short=7 "$hash")
      cdate=$(git show -s --format=%ci "$hash" 2>/dev/null || true)
      cdate=${cdate%% *}
      subject=$(git show -s --format=%s "$hash" 2>/dev/null || true)
      if [ -z "$subject" ]; then subject="$msg"; fi
      entry="- \\`$short\\`  $cdate — $subject"
    else
      # unknown hash locally, print raw hash and the message from file
      entry="- \\`$hash\\`  — $msg"
    fi

    # append to entries_by_version
    if [ -z "${entries_by_version[$key]:-}" ]; then
      entries_by_version[$key]="$entry\n"
    else
      entries_by_version[$key]="${entries_by_version[$key]}$entry\n"
    fi
  done < <(grep -E '^v' "$file" || true)
}

# Generate release notes directly from Git history
process_git_history() {
  local version="$1"
  local since_commit="$2"
  local out_file="$OUT_DIR/Release-${version}.md"

  mkdir -p "$OUT_DIR"
  {
    echo "# Release ${version}"
    echo
    echo "_Generated from Git history since commit: ${since_commit}_"
    echo
    git log --pretty=format:"- %h %ad %s" --date=short "${since_commit}..HEAD"
    echo
    echo "---"
    echo "Generated by aggregate_release_notes.sh"
  } > "$out_file"

  echo "Generated release notes: $out_file"
}

# process all files
for p in "${RN_GLOBS[@]}"; do
  for f in $p; do
    [ -f "$f" ] || continue
    echo "Reading: $f" >&2
    process_file "$f"
  done
done

# Emit Markdown
mkdir -p "$OUT_DIR" >/dev/null 2>&1 || true
for ver in "${version_order[@]}"; do
  d=${version_date[$ver]:-}
  # nice file name safe
  out_file="$OUT_DIR/Release-${ver}.md"

  # build content
  echo "------------------------------------------------------------"
  echo "## ${ver} — ${d}"
  echo
  printf "%b" "${entries_by_version[$ver]:-}" | sed 's/^/\n/' | sed '/^$/d'
  echo
  echo "------------------------------------------------------------"
  echo

  if [ "$WRITE" -eq 1 ]; then
    {
      echo "# Release ${ver}"
      echo
      echo "_Release date: ${d}_"
      echo
      printf "%b" "${entries_by_version[$ver]:-}" | sed '/^$/d'
      echo
      echo "---"
      echo
      echo "Generated by scripts/aggregate_release_notes.sh"
    } > "$out_file"
    echo "Wrote $out_file" >&2
  fi
done

exit 0
